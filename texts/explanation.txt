


<h3>Evaluation Criteria</h3>
    <p>
        To effectively compare Linear Search and Binary Search, several key criteria are used to evaluate and understand how each algorithm operates and performs. These criteria help provide a structured comparison based on both theoretical understanding and practical application. Listed below are brief explanations of what each criterion focuses on: 
    </p>
        <ol>
            <li>
                <strong>How It Works:</strong>
                <p>This refers to the fundamental logic or principle that defines how the algorithm functions. It explains the general strategy used to search for a target value within a dataset, whether it's through sequential checking, division, or other techniques.</p>            
            </li>
            <li>
                <strong>Working Steps:</strong>
                <p>This involves a breakdown of the algorithm's execution process using a sample input. It includes each step performed during the search, such as comparisons, index movement, or recursive calls, providing a visual understanding of the algorithm’s flow.</p>            
            </li>
            <li>
                <strong>Time Complexity:</strong>
                <p>Time complexity evaluates the efficiency of the algorithm in terms of the time it takes to run as the input size grows. It typically considers three scenarios</p>
                <ul>
                    <li><b>Best Case -</b> The minimum number of operations required</li>
                    <li><b>Average Case -</b> The expected number of operations for a typical input</li>
                    <li><b>Worst Case -</b> The maximum number of operations required</li>
                </ul> 
                <br>       
            </li>
            <li>
                <strong>Space Complexity:</strong>
                <p>This measures how much extra memory the algorithm needs to run, excluding the input data itself. It helps determine whether the algorithm is memory-efficient or requires additional storage for variables, recursive calls, or data structures.</p>            
            </li>
            <li>
                <strong>Pros And Cons:</strong>
                <p>This criterion outlines the strengths and weaknesses of each algorithm. It considers factors like simplicity, flexibility, performance, data requirements, and ease of implementation. Understanding the advantages and limitations helps decide when an algorithm is best suited for a given scenario.</p>            
            </li>
        </ol>


<h3>Linear Search</h3>
    <p>
        Linear Search, also known as sequential search, is the most basic type of searching algorithm that checks each element in a list one by one until the target element is found or the end of the list is reached. Unlike binary search, linear search does not require the data to be sorted. This algorithm is simple to implement and works well for small or unsorted datasets. However, it can be inefficient for large data sets. The time complexity of linear search is O(n), which means it can take longer to find an item as the dataset grows. 
    </p>
        <ol>
            <li>
                <strong>How Linear Search Works:</strong>
                <ol>
                    <li>Start from the first element of the array or list.</li>
                    <li>Compare the current element with the target value.</li>
                    <li>If the current element matches the target, the search is successful, and the process is terminated. </li>
                    <li>If the current element does not match, move to the next element. </li>
                    <li>Continue the process until the target element is found or the end of the array is reached. </li>
                    <li>If the target is not found by the time the loop ends, the search is unsuccessful. </li>
                </ol>
                <br>
            </li>
            <li>
                <strong>Time complexities of Linear Search:</strong>
                <ul>
                    <li><b>Best case complexity: O(1) — </b>when the target is the first element. </li>
                    <li><b>Average case complexity: O(n) — </b>when the target is somewhere in the middle. </li>
                    <li><b>Worst case complexity: O(n) — </b>when the target is the last element or not present at all. </li>
                </ul>
                <br>
            </li>
            <li>
                <strong>Space Complexity of Linear Search:</strong>
                <ul>
                <li><b>O(1) — </b>constant space is used since it does not require any extra storage regardless of input size. </li> 
                </ul>           
            </li>
            <br>
            <li>
                <strong>Pros of Linear Search:</strong>
                <ul>
                    <li>Very simple and easy to implement.</li>
                    <li>Works on both sorted and unsorted data. </li>
                    <li>Can be used on any data structure, including arrays and linked lists.</li>
                </ul>
                <br>
            </li>
            <li>
                <strong>Cons of Linear Search:</strong>
                <ul>
                    <li>Inefficient for large datasets. </li>
                    <li>More time-consuming compared to binary search. </li>
                    <li>Checks each element even when not necessary in worst cases. </li>
                </ul>
                <br>
            </li>
        </ol>

<h3>Binary Search</h3>
    <p>
        Binary Search also known as half-interval search is another type of searching algorithm that uses sorted array by dividing the search interval in half. Binary search can be implemented only on a sorted list of items. If the elements are not sorted already, we need to sort them first. Binary search time complexity is O(log n) which is half of the time complexity of linear search. Conditions to apply Binary Search Algorithm in a Data Structure are the data must be sorted and access to any element of the data structure should take constant time.
    </p>
        <ol>
            <li>
                <strong>How Binary Search Works:</strong>
                <ol>
                    <li>Firstly, we must make sure that the array is sorted.</li>
                    <li>Divide the search space into two halves by finding the middle index, mid. Mid=(low+high)/2. Low firstly is the lowest element in the array and high is the highest element.</li>
                    <li>Compare the mid element with the target data. If the mid is equal to the target, then the data is found, and the process is terminated.</li>
                    <li>If the target is not found, we must see if the target is larger than the mid or smaller. If the target is larger then use the larger side of the searching space and the new low = mid+1. If the target is smaller, then use the smaller side of the searching space and the new high = mid-1.</li>
                    <li>Continue the same process from step 2 with the new half of searching space after discarding the unused half searching space until the target is found.</li>
                </ol>
                <br>
            </li>
            <li>
                <strong>Time complexities of Binary Search:</strong>
                <ul>
                    <li><b>Best case complexity: O(1) — </b> when the target is found at the middle index on the first comparison.</li>
                    <li><b>Average case complexity: O(log n) — </b> the search space is halved each time, so it takes log₂(n) steps on average to find the target.</li>
                    <li><b>Worst case complexity: O(log n) — </b> when the target is located at one of the ends or not present, still requires log₂(n) comparisons.</li>
                </ul>
                <br>
            </li>
            <li>
                <strong>Space Complexity of Binary Search:</strong>
                <ul>
                    <li><b>Iterative Binary Search: O(1) — </b>uses only a few variables (low, high, mid), no additional memory needed. </li>
                    <li><b>Recursive Binary Search: O(log n) — </b>each recursive call adds a new layer to the call stack, leading to log₂(n) stack space.</li>
                </ul> 
                <br>
            </li>
            <li>
                <strong>Pros of Binary Search:</strong>
                <ul>
                    <li>Very fast for large dataset.</li>
                    <li>Cuts the search time in half for each iteration.</li>
                    <li>Fewer operation needed.</li>
                </ul>
                <br>
            </li>
            <li>
                <strong>Cons of Binary Search:</strong>
                <ul>
                    <li>Only works on sorted data.</li>
                    <li>Slightly more complex than linear search to implement. </li>
                    <li>Only suitable with data structure that has random access (e.g: array)</li>
                </ul>
                <br>
            </li>
        </ol>